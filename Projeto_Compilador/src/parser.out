Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM id ; declarations block .
Rule 2     block -> BEGIN statements END terminator
Rule 3     declarations -> VAR declaration_list ;
Rule 4     declarations -> CONST declaration_list ;
Rule 5     declarations -> VAR declaration_list CONST declaration_list
Rule 6     declarations -> CONST declaration_list VAR declaration_list
Rule 7     declarations -> <empty>
Rule 8     declaration_list -> declaration
Rule 9     declaration_list -> declaration_list ; declaration
Rule 10    declaration -> id_list : type
Rule 11    id_list -> id
Rule 12    id_list -> id_list , id
Rule 13    type -> INTEGER
Rule 14    type -> REAL
Rule 15    type -> STRING
Rule 16    type -> CHAR
Rule 17    type -> BOOLEAN
Rule 18    type -> ARRAY [ expression ] OF type
Rule 19    statements -> statement
Rule 20    statements -> statements statement
Rule 21    statement -> block
Rule 22    statement -> assignment
Rule 23    statement -> if_statement
Rule 24    statement -> while_statement
Rule 25    statement -> for_statement
Rule 26    statement -> comments
Rule 27    statement -> function_call
Rule 28    assignment -> id ASSIGN expression
Rule 29    if_statement -> IF exprBool THEN statement ifCont
Rule 30    ifCont -> <empty>
Rule 31    ifCont -> ELSE statement
Rule 32    while_statement -> WHILE expression DO statement
Rule 33    for_statement -> FOR id ASSIGN expression forCont
Rule 34    forCont -> TO expression DO statement
Rule 35    forCont -> DOWNTO expression DO statement
Rule 36    exprBool -> expression
Rule 37    exprBool -> expression opRel expression
Rule 38    exprBool -> NOT expression
Rule 39    opRel -> =
Rule 40    opRel -> NOTEQUAL
Rule 41    opRel -> <
Rule 42    opRel -> >
Rule 43    opRel -> MINOREQUALS
Rule 44    opRel -> LARGEREQUALS
Rule 45    expression -> term
Rule 46    expression -> expression opAdd term
Rule 47    expression -> num TWODOTS num
Rule 48    opAdd -> +
Rule 49    opAdd -> -
Rule 50    opAdd -> OR
Rule 51    term -> factor
Rule 52    term -> term opMul factor
Rule 53    opMul -> *
Rule 54    opMul -> /
Rule 55    opMul -> %
Rule 56    opMul -> AND
Rule 57    opMul -> MOD
Rule 58    opMul -> DIV
Rule 59    factor -> const terminator
Rule 60    factor -> var terminator
Rule 61    factor -> function_call
Rule 62    factor -> ( exprBool )
Rule 63    const -> num
Rule 64    const -> text
Rule 65    const -> TRUE
Rule 66    const -> FALSE
Rule 67    var -> id
Rule 68    var -> id [ expression ]
Rule 69    function_call -> id ( ) terminator
Rule 70    function_call -> id ( arg_list ) terminator
Rule 71    terminator -> ;
Rule 72    terminator -> <empty>
Rule 73    arg_list -> expression
Rule 74    arg_list -> arg_list , expression
Rule 75    comments -> comment

Terminals, with rules where they appear

%                    : 55
(                    : 62 69 70
)                    : 62 69 70
*                    : 53
+                    : 48
,                    : 12 74
-                    : 49
.                    : 1
/                    : 54
:                    : 10
;                    : 1 3 4 9 71
<                    : 41
=                    : 39
>                    : 42
AND                  : 56
ARRAY                : 18
ASSIGN               : 28 33
BEGIN                : 2
BOOLEAN              : 17
CHAR                 : 16
CONST                : 4 5 6
DIV                  : 58
DO                   : 32 34 35
DOWNTO               : 35
ELSE                 : 31
END                  : 2
FALSE                : 66
FOR                  : 33
IF                   : 29
INTEGER              : 13
LARGEREQUALS         : 44
MINOREQUALS          : 43
MOD                  : 57
NOT                  : 38
NOTEQUAL             : 40
OF                   : 18
OR                   : 50
PROGRAM              : 1
REAL                 : 14
STRING               : 15
THEN                 : 29
TO                   : 34
TRUE                 : 65
TWODOTS              : 47
VAR                  : 3 5 6
WHILE                : 32
[                    : 18 68
]                    : 18 68
comment              : 75
error                : 
id                   : 1 11 12 28 33 67 68 69 70
num                  : 47 47 63
text                 : 64

Nonterminals, with rules where they appear

arg_list             : 70 74
assignment           : 22
block                : 1 21
comments             : 26
const                : 59
declaration          : 8 9
declaration_list     : 3 4 5 5 6 6 9
declarations         : 1
exprBool             : 29 62
expression           : 18 28 32 33 34 35 36 37 37 38 46 68 73 74
factor               : 51 52
forCont              : 33
for_statement        : 25
function_call        : 27 61
id_list              : 10 12
ifCont               : 29
if_statement         : 23
opAdd                : 46
opMul                : 52
opRel                : 37
program              : 0
statement            : 19 20 29 31 32 34 35
statements           : 2 20
term                 : 45 46 52
terminator           : 2 59 60 69 70
type                 : 10 18
var                  : 60
while_statement      : 24

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM id ; declarations block .

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . id ; declarations block .

    id              shift and go to state 3


state 3

    (1) program -> PROGRAM id . ; declarations block .

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM id ; . declarations block .
    (3) declarations -> . VAR declaration_list ;
    (4) declarations -> . CONST declaration_list ;
    (5) declarations -> . VAR declaration_list CONST declaration_list
    (6) declarations -> . CONST declaration_list VAR declaration_list
    (7) declarations -> .

    VAR             shift and go to state 6
    CONST           shift and go to state 7
    BEGIN           reduce using rule 7 (declarations -> .)

    declarations                   shift and go to state 5

state 5

    (1) program -> PROGRAM id ; declarations . block .
    (2) block -> . BEGIN statements END terminator

    BEGIN           shift and go to state 9

    block                          shift and go to state 8

state 6

    (3) declarations -> VAR . declaration_list ;
    (5) declarations -> VAR . declaration_list CONST declaration_list
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list ; declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    id              shift and go to state 13

    declaration_list               shift and go to state 10
    declaration                    shift and go to state 11
    id_list                        shift and go to state 12

state 7

    (4) declarations -> CONST . declaration_list ;
    (6) declarations -> CONST . declaration_list VAR declaration_list
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list ; declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    id              shift and go to state 13

    declaration_list               shift and go to state 14
    declaration                    shift and go to state 11
    id_list                        shift and go to state 12

state 8

    (1) program -> PROGRAM id ; declarations block . .

    .               shift and go to state 15


state 9

    (2) block -> BEGIN . statements END terminator
    (19) statements -> . statement
    (20) statements -> . statements statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statements                     shift and go to state 16
    statement                      shift and go to state 17
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 10

    (3) declarations -> VAR declaration_list . ;
    (5) declarations -> VAR declaration_list . CONST declaration_list
    (9) declaration_list -> declaration_list . ; declaration

    ;               shift and go to state 30
    CONST           shift and go to state 31


state 11

    (8) declaration_list -> declaration .

    ;               reduce using rule 8 (declaration_list -> declaration .)
    CONST           reduce using rule 8 (declaration_list -> declaration .)
    VAR             reduce using rule 8 (declaration_list -> declaration .)
    BEGIN           reduce using rule 8 (declaration_list -> declaration .)


state 12

    (10) declaration -> id_list . : type
    (12) id_list -> id_list . , id

    :               shift and go to state 32
    ,               shift and go to state 33


state 13

    (11) id_list -> id .

    :               reduce using rule 11 (id_list -> id .)
    ,               reduce using rule 11 (id_list -> id .)


state 14

    (4) declarations -> CONST declaration_list . ;
    (6) declarations -> CONST declaration_list . VAR declaration_list
    (9) declaration_list -> declaration_list . ; declaration

    ;               shift and go to state 34
    VAR             shift and go to state 35


state 15

    (1) program -> PROGRAM id ; declarations block . .

    $end            reduce using rule 1 (program -> PROGRAM id ; declarations block . .)


state 16

    (2) block -> BEGIN statements . END terminator
    (20) statements -> statements . statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    END             shift and go to state 36
    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 37
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 17

    (19) statements -> statement .

    END             reduce using rule 19 (statements -> statement .)
    BEGIN           reduce using rule 19 (statements -> statement .)
    id              reduce using rule 19 (statements -> statement .)
    IF              reduce using rule 19 (statements -> statement .)
    WHILE           reduce using rule 19 (statements -> statement .)
    FOR             reduce using rule 19 (statements -> statement .)
    comment         reduce using rule 19 (statements -> statement .)


state 18

    (21) statement -> block .

    END             reduce using rule 21 (statement -> block .)
    BEGIN           reduce using rule 21 (statement -> block .)
    id              reduce using rule 21 (statement -> block .)
    IF              reduce using rule 21 (statement -> block .)
    WHILE           reduce using rule 21 (statement -> block .)
    FOR             reduce using rule 21 (statement -> block .)
    comment         reduce using rule 21 (statement -> block .)
    ELSE            reduce using rule 21 (statement -> block .)


state 19

    (22) statement -> assignment .

    END             reduce using rule 22 (statement -> assignment .)
    BEGIN           reduce using rule 22 (statement -> assignment .)
    id              reduce using rule 22 (statement -> assignment .)
    IF              reduce using rule 22 (statement -> assignment .)
    WHILE           reduce using rule 22 (statement -> assignment .)
    FOR             reduce using rule 22 (statement -> assignment .)
    comment         reduce using rule 22 (statement -> assignment .)
    ELSE            reduce using rule 22 (statement -> assignment .)


state 20

    (23) statement -> if_statement .

    END             reduce using rule 23 (statement -> if_statement .)
    BEGIN           reduce using rule 23 (statement -> if_statement .)
    id              reduce using rule 23 (statement -> if_statement .)
    IF              reduce using rule 23 (statement -> if_statement .)
    WHILE           reduce using rule 23 (statement -> if_statement .)
    FOR             reduce using rule 23 (statement -> if_statement .)
    comment         reduce using rule 23 (statement -> if_statement .)
    ELSE            reduce using rule 23 (statement -> if_statement .)


state 21

    (24) statement -> while_statement .

    END             reduce using rule 24 (statement -> while_statement .)
    BEGIN           reduce using rule 24 (statement -> while_statement .)
    id              reduce using rule 24 (statement -> while_statement .)
    IF              reduce using rule 24 (statement -> while_statement .)
    WHILE           reduce using rule 24 (statement -> while_statement .)
    FOR             reduce using rule 24 (statement -> while_statement .)
    comment         reduce using rule 24 (statement -> while_statement .)
    ELSE            reduce using rule 24 (statement -> while_statement .)


state 22

    (25) statement -> for_statement .

    END             reduce using rule 25 (statement -> for_statement .)
    BEGIN           reduce using rule 25 (statement -> for_statement .)
    id              reduce using rule 25 (statement -> for_statement .)
    IF              reduce using rule 25 (statement -> for_statement .)
    WHILE           reduce using rule 25 (statement -> for_statement .)
    FOR             reduce using rule 25 (statement -> for_statement .)
    comment         reduce using rule 25 (statement -> for_statement .)
    ELSE            reduce using rule 25 (statement -> for_statement .)


state 23

    (26) statement -> comments .

    END             reduce using rule 26 (statement -> comments .)
    BEGIN           reduce using rule 26 (statement -> comments .)
    id              reduce using rule 26 (statement -> comments .)
    IF              reduce using rule 26 (statement -> comments .)
    WHILE           reduce using rule 26 (statement -> comments .)
    FOR             reduce using rule 26 (statement -> comments .)
    comment         reduce using rule 26 (statement -> comments .)
    ELSE            reduce using rule 26 (statement -> comments .)


state 24

    (27) statement -> function_call .

    END             reduce using rule 27 (statement -> function_call .)
    BEGIN           reduce using rule 27 (statement -> function_call .)
    id              reduce using rule 27 (statement -> function_call .)
    IF              reduce using rule 27 (statement -> function_call .)
    WHILE           reduce using rule 27 (statement -> function_call .)
    FOR             reduce using rule 27 (statement -> function_call .)
    comment         reduce using rule 27 (statement -> function_call .)
    ELSE            reduce using rule 27 (statement -> function_call .)


state 25

    (28) assignment -> id . ASSIGN expression
    (69) function_call -> id . ( ) terminator
    (70) function_call -> id . ( arg_list ) terminator

    ASSIGN          shift and go to state 38
    (               shift and go to state 39


state 26

    (29) if_statement -> IF . exprBool THEN statement ifCont
    (36) exprBool -> . expression
    (37) exprBool -> . expression opRel expression
    (38) exprBool -> . NOT expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    NOT             shift and go to state 42
    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    exprBool                       shift and go to state 40
    expression                     shift and go to state 41
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 27

    (32) while_statement -> WHILE . expression DO statement
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 54
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 28

    (33) for_statement -> FOR . id ASSIGN expression forCont

    id              shift and go to state 55


state 29

    (75) comments -> comment .

    END             reduce using rule 75 (comments -> comment .)
    BEGIN           reduce using rule 75 (comments -> comment .)
    id              reduce using rule 75 (comments -> comment .)
    IF              reduce using rule 75 (comments -> comment .)
    WHILE           reduce using rule 75 (comments -> comment .)
    FOR             reduce using rule 75 (comments -> comment .)
    comment         reduce using rule 75 (comments -> comment .)
    ELSE            reduce using rule 75 (comments -> comment .)


state 30

    (3) declarations -> VAR declaration_list ; .
    (9) declaration_list -> declaration_list ; . declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    BEGIN           reduce using rule 3 (declarations -> VAR declaration_list ; .)
    id              shift and go to state 13

    declaration                    shift and go to state 56
    id_list                        shift and go to state 12

state 31

    (5) declarations -> VAR declaration_list CONST . declaration_list
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list ; declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    id              shift and go to state 13

    declaration_list               shift and go to state 57
    declaration                    shift and go to state 11
    id_list                        shift and go to state 12

state 32

    (10) declaration -> id_list : . type
    (13) type -> . INTEGER
    (14) type -> . REAL
    (15) type -> . STRING
    (16) type -> . CHAR
    (17) type -> . BOOLEAN
    (18) type -> . ARRAY [ expression ] OF type

    INTEGER         shift and go to state 59
    REAL            shift and go to state 60
    STRING          shift and go to state 61
    CHAR            shift and go to state 62
    BOOLEAN         shift and go to state 63
    ARRAY           shift and go to state 64

    type                           shift and go to state 58

state 33

    (12) id_list -> id_list , . id

    id              shift and go to state 65


state 34

    (4) declarations -> CONST declaration_list ; .
    (9) declaration_list -> declaration_list ; . declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    BEGIN           reduce using rule 4 (declarations -> CONST declaration_list ; .)
    id              shift and go to state 13

    declaration                    shift and go to state 56
    id_list                        shift and go to state 12

state 35

    (6) declarations -> CONST declaration_list VAR . declaration_list
    (8) declaration_list -> . declaration
    (9) declaration_list -> . declaration_list ; declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    id              shift and go to state 13

    declaration_list               shift and go to state 66
    declaration                    shift and go to state 11
    id_list                        shift and go to state 12

state 36

    (2) block -> BEGIN statements END . terminator
    (71) terminator -> . ;
    (72) terminator -> .

    ;               shift and go to state 68
    .               reduce using rule 72 (terminator -> .)
    END             reduce using rule 72 (terminator -> .)
    BEGIN           reduce using rule 72 (terminator -> .)
    id              reduce using rule 72 (terminator -> .)
    IF              reduce using rule 72 (terminator -> .)
    WHILE           reduce using rule 72 (terminator -> .)
    FOR             reduce using rule 72 (terminator -> .)
    comment         reduce using rule 72 (terminator -> .)
    ELSE            reduce using rule 72 (terminator -> .)

    terminator                     shift and go to state 67

state 37

    (20) statements -> statements statement .

    END             reduce using rule 20 (statements -> statements statement .)
    BEGIN           reduce using rule 20 (statements -> statements statement .)
    id              reduce using rule 20 (statements -> statements statement .)
    IF              reduce using rule 20 (statements -> statements statement .)
    WHILE           reduce using rule 20 (statements -> statements statement .)
    FOR             reduce using rule 20 (statements -> statements statement .)
    comment         reduce using rule 20 (statements -> statements statement .)


state 38

    (28) assignment -> id ASSIGN . expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 69
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 39

    (69) function_call -> id ( . ) terminator
    (70) function_call -> id ( . arg_list ) terminator
    (73) arg_list -> . expression
    (74) arg_list -> . arg_list , expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    )               shift and go to state 70
    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    arg_list                       shift and go to state 71
    expression                     shift and go to state 72
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 40

    (29) if_statement -> IF exprBool . THEN statement ifCont

    THEN            shift and go to state 73


state 41

    (36) exprBool -> expression .
    (37) exprBool -> expression . opRel expression
    (46) expression -> expression . opAdd term
    (39) opRel -> . =
    (40) opRel -> . NOTEQUAL
    (41) opRel -> . <
    (42) opRel -> . >
    (43) opRel -> . MINOREQUALS
    (44) opRel -> . LARGEREQUALS
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    THEN            reduce using rule 36 (exprBool -> expression .)
    )               reduce using rule 36 (exprBool -> expression .)
    =               shift and go to state 76
    NOTEQUAL        shift and go to state 77
    <               shift and go to state 78
    >               shift and go to state 79
    MINOREQUALS     shift and go to state 80
    LARGEREQUALS    shift and go to state 81
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opRel                          shift and go to state 74
    opAdd                          shift and go to state 75

state 42

    (38) exprBool -> NOT . expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 85
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 43

    (45) expression -> term .
    (52) term -> term . opMul factor
    (53) opMul -> . *
    (54) opMul -> . /
    (55) opMul -> . %
    (56) opMul -> . AND
    (57) opMul -> . MOD
    (58) opMul -> . DIV

    =               reduce using rule 45 (expression -> term .)
    NOTEQUAL        reduce using rule 45 (expression -> term .)
    <               reduce using rule 45 (expression -> term .)
    >               reduce using rule 45 (expression -> term .)
    MINOREQUALS     reduce using rule 45 (expression -> term .)
    LARGEREQUALS    reduce using rule 45 (expression -> term .)
    +               reduce using rule 45 (expression -> term .)
    -               reduce using rule 45 (expression -> term .)
    OR              reduce using rule 45 (expression -> term .)
    THEN            reduce using rule 45 (expression -> term .)
    DO              reduce using rule 45 (expression -> term .)
    END             reduce using rule 45 (expression -> term .)
    BEGIN           reduce using rule 45 (expression -> term .)
    id              reduce using rule 45 (expression -> term .)
    IF              reduce using rule 45 (expression -> term .)
    WHILE           reduce using rule 45 (expression -> term .)
    FOR             reduce using rule 45 (expression -> term .)
    comment         reduce using rule 45 (expression -> term .)
    ELSE            reduce using rule 45 (expression -> term .)
    )               reduce using rule 45 (expression -> term .)
    ,               reduce using rule 45 (expression -> term .)
    ]               reduce using rule 45 (expression -> term .)
    TO              reduce using rule 45 (expression -> term .)
    DOWNTO          reduce using rule 45 (expression -> term .)
    *               shift and go to state 87
    /               shift and go to state 88
    %               shift and go to state 89
    AND             shift and go to state 90
    MOD             shift and go to state 91
    DIV             shift and go to state 92

    opMul                          shift and go to state 86

state 44

    (47) expression -> num . TWODOTS num
    (63) const -> num .

    TWODOTS         shift and go to state 93
    ;               reduce using rule 63 (const -> num .)
    *               reduce using rule 63 (const -> num .)
    /               reduce using rule 63 (const -> num .)
    %               reduce using rule 63 (const -> num .)
    AND             reduce using rule 63 (const -> num .)
    MOD             reduce using rule 63 (const -> num .)
    DIV             reduce using rule 63 (const -> num .)
    =               reduce using rule 63 (const -> num .)
    NOTEQUAL        reduce using rule 63 (const -> num .)
    <               reduce using rule 63 (const -> num .)
    >               reduce using rule 63 (const -> num .)
    MINOREQUALS     reduce using rule 63 (const -> num .)
    LARGEREQUALS    reduce using rule 63 (const -> num .)
    +               reduce using rule 63 (const -> num .)
    -               reduce using rule 63 (const -> num .)
    OR              reduce using rule 63 (const -> num .)
    THEN            reduce using rule 63 (const -> num .)
    DO              reduce using rule 63 (const -> num .)
    END             reduce using rule 63 (const -> num .)
    BEGIN           reduce using rule 63 (const -> num .)
    id              reduce using rule 63 (const -> num .)
    IF              reduce using rule 63 (const -> num .)
    WHILE           reduce using rule 63 (const -> num .)
    FOR             reduce using rule 63 (const -> num .)
    comment         reduce using rule 63 (const -> num .)
    ELSE            reduce using rule 63 (const -> num .)
    )               reduce using rule 63 (const -> num .)
    ,               reduce using rule 63 (const -> num .)
    ]               reduce using rule 63 (const -> num .)
    TO              reduce using rule 63 (const -> num .)
    DOWNTO          reduce using rule 63 (const -> num .)


state 45

    (51) term -> factor .

    *               reduce using rule 51 (term -> factor .)
    /               reduce using rule 51 (term -> factor .)
    %               reduce using rule 51 (term -> factor .)
    AND             reduce using rule 51 (term -> factor .)
    MOD             reduce using rule 51 (term -> factor .)
    DIV             reduce using rule 51 (term -> factor .)
    =               reduce using rule 51 (term -> factor .)
    NOTEQUAL        reduce using rule 51 (term -> factor .)
    <               reduce using rule 51 (term -> factor .)
    >               reduce using rule 51 (term -> factor .)
    MINOREQUALS     reduce using rule 51 (term -> factor .)
    LARGEREQUALS    reduce using rule 51 (term -> factor .)
    +               reduce using rule 51 (term -> factor .)
    -               reduce using rule 51 (term -> factor .)
    OR              reduce using rule 51 (term -> factor .)
    THEN            reduce using rule 51 (term -> factor .)
    DO              reduce using rule 51 (term -> factor .)
    END             reduce using rule 51 (term -> factor .)
    BEGIN           reduce using rule 51 (term -> factor .)
    id              reduce using rule 51 (term -> factor .)
    IF              reduce using rule 51 (term -> factor .)
    WHILE           reduce using rule 51 (term -> factor .)
    FOR             reduce using rule 51 (term -> factor .)
    comment         reduce using rule 51 (term -> factor .)
    ELSE            reduce using rule 51 (term -> factor .)
    )               reduce using rule 51 (term -> factor .)
    ,               reduce using rule 51 (term -> factor .)
    ]               reduce using rule 51 (term -> factor .)
    TO              reduce using rule 51 (term -> factor .)
    DOWNTO          reduce using rule 51 (term -> factor .)


state 46

    (59) factor -> const . terminator
    (71) terminator -> . ;
    (72) terminator -> .

    ;               shift and go to state 68
    *               reduce using rule 72 (terminator -> .)
    /               reduce using rule 72 (terminator -> .)
    %               reduce using rule 72 (terminator -> .)
    AND             reduce using rule 72 (terminator -> .)
    MOD             reduce using rule 72 (terminator -> .)
    DIV             reduce using rule 72 (terminator -> .)
    =               reduce using rule 72 (terminator -> .)
    NOTEQUAL        reduce using rule 72 (terminator -> .)
    <               reduce using rule 72 (terminator -> .)
    >               reduce using rule 72 (terminator -> .)
    MINOREQUALS     reduce using rule 72 (terminator -> .)
    LARGEREQUALS    reduce using rule 72 (terminator -> .)
    +               reduce using rule 72 (terminator -> .)
    -               reduce using rule 72 (terminator -> .)
    OR              reduce using rule 72 (terminator -> .)
    THEN            reduce using rule 72 (terminator -> .)
    DO              reduce using rule 72 (terminator -> .)
    END             reduce using rule 72 (terminator -> .)
    BEGIN           reduce using rule 72 (terminator -> .)
    id              reduce using rule 72 (terminator -> .)
    IF              reduce using rule 72 (terminator -> .)
    WHILE           reduce using rule 72 (terminator -> .)
    FOR             reduce using rule 72 (terminator -> .)
    comment         reduce using rule 72 (terminator -> .)
    ELSE            reduce using rule 72 (terminator -> .)
    )               reduce using rule 72 (terminator -> .)
    ,               reduce using rule 72 (terminator -> .)
    ]               reduce using rule 72 (terminator -> .)
    TO              reduce using rule 72 (terminator -> .)
    DOWNTO          reduce using rule 72 (terminator -> .)

    terminator                     shift and go to state 94

state 47

    (60) factor -> var . terminator
    (71) terminator -> . ;
    (72) terminator -> .

    ;               shift and go to state 68
    *               reduce using rule 72 (terminator -> .)
    /               reduce using rule 72 (terminator -> .)
    %               reduce using rule 72 (terminator -> .)
    AND             reduce using rule 72 (terminator -> .)
    MOD             reduce using rule 72 (terminator -> .)
    DIV             reduce using rule 72 (terminator -> .)
    =               reduce using rule 72 (terminator -> .)
    NOTEQUAL        reduce using rule 72 (terminator -> .)
    <               reduce using rule 72 (terminator -> .)
    >               reduce using rule 72 (terminator -> .)
    MINOREQUALS     reduce using rule 72 (terminator -> .)
    LARGEREQUALS    reduce using rule 72 (terminator -> .)
    +               reduce using rule 72 (terminator -> .)
    -               reduce using rule 72 (terminator -> .)
    OR              reduce using rule 72 (terminator -> .)
    THEN            reduce using rule 72 (terminator -> .)
    DO              reduce using rule 72 (terminator -> .)
    END             reduce using rule 72 (terminator -> .)
    BEGIN           reduce using rule 72 (terminator -> .)
    id              reduce using rule 72 (terminator -> .)
    IF              reduce using rule 72 (terminator -> .)
    WHILE           reduce using rule 72 (terminator -> .)
    FOR             reduce using rule 72 (terminator -> .)
    comment         reduce using rule 72 (terminator -> .)
    ELSE            reduce using rule 72 (terminator -> .)
    )               reduce using rule 72 (terminator -> .)
    ,               reduce using rule 72 (terminator -> .)
    ]               reduce using rule 72 (terminator -> .)
    TO              reduce using rule 72 (terminator -> .)
    DOWNTO          reduce using rule 72 (terminator -> .)

    terminator                     shift and go to state 95

state 48

    (61) factor -> function_call .

    *               reduce using rule 61 (factor -> function_call .)
    /               reduce using rule 61 (factor -> function_call .)
    %               reduce using rule 61 (factor -> function_call .)
    AND             reduce using rule 61 (factor -> function_call .)
    MOD             reduce using rule 61 (factor -> function_call .)
    DIV             reduce using rule 61 (factor -> function_call .)
    =               reduce using rule 61 (factor -> function_call .)
    NOTEQUAL        reduce using rule 61 (factor -> function_call .)
    <               reduce using rule 61 (factor -> function_call .)
    >               reduce using rule 61 (factor -> function_call .)
    MINOREQUALS     reduce using rule 61 (factor -> function_call .)
    LARGEREQUALS    reduce using rule 61 (factor -> function_call .)
    +               reduce using rule 61 (factor -> function_call .)
    -               reduce using rule 61 (factor -> function_call .)
    OR              reduce using rule 61 (factor -> function_call .)
    THEN            reduce using rule 61 (factor -> function_call .)
    DO              reduce using rule 61 (factor -> function_call .)
    END             reduce using rule 61 (factor -> function_call .)
    BEGIN           reduce using rule 61 (factor -> function_call .)
    id              reduce using rule 61 (factor -> function_call .)
    IF              reduce using rule 61 (factor -> function_call .)
    WHILE           reduce using rule 61 (factor -> function_call .)
    FOR             reduce using rule 61 (factor -> function_call .)
    comment         reduce using rule 61 (factor -> function_call .)
    ELSE            reduce using rule 61 (factor -> function_call .)
    )               reduce using rule 61 (factor -> function_call .)
    ,               reduce using rule 61 (factor -> function_call .)
    ]               reduce using rule 61 (factor -> function_call .)
    TO              reduce using rule 61 (factor -> function_call .)
    DOWNTO          reduce using rule 61 (factor -> function_call .)


state 49

    (62) factor -> ( . exprBool )
    (36) exprBool -> . expression
    (37) exprBool -> . expression opRel expression
    (38) exprBool -> . NOT expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    NOT             shift and go to state 42
    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    exprBool                       shift and go to state 96
    expression                     shift and go to state 41
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 50

    (64) const -> text .

    ;               reduce using rule 64 (const -> text .)
    *               reduce using rule 64 (const -> text .)
    /               reduce using rule 64 (const -> text .)
    %               reduce using rule 64 (const -> text .)
    AND             reduce using rule 64 (const -> text .)
    MOD             reduce using rule 64 (const -> text .)
    DIV             reduce using rule 64 (const -> text .)
    =               reduce using rule 64 (const -> text .)
    NOTEQUAL        reduce using rule 64 (const -> text .)
    <               reduce using rule 64 (const -> text .)
    >               reduce using rule 64 (const -> text .)
    MINOREQUALS     reduce using rule 64 (const -> text .)
    LARGEREQUALS    reduce using rule 64 (const -> text .)
    +               reduce using rule 64 (const -> text .)
    -               reduce using rule 64 (const -> text .)
    OR              reduce using rule 64 (const -> text .)
    THEN            reduce using rule 64 (const -> text .)
    DO              reduce using rule 64 (const -> text .)
    END             reduce using rule 64 (const -> text .)
    BEGIN           reduce using rule 64 (const -> text .)
    id              reduce using rule 64 (const -> text .)
    IF              reduce using rule 64 (const -> text .)
    WHILE           reduce using rule 64 (const -> text .)
    FOR             reduce using rule 64 (const -> text .)
    comment         reduce using rule 64 (const -> text .)
    ELSE            reduce using rule 64 (const -> text .)
    )               reduce using rule 64 (const -> text .)
    ,               reduce using rule 64 (const -> text .)
    ]               reduce using rule 64 (const -> text .)
    TO              reduce using rule 64 (const -> text .)
    DOWNTO          reduce using rule 64 (const -> text .)


state 51

    (65) const -> TRUE .

    ;               reduce using rule 65 (const -> TRUE .)
    *               reduce using rule 65 (const -> TRUE .)
    /               reduce using rule 65 (const -> TRUE .)
    %               reduce using rule 65 (const -> TRUE .)
    AND             reduce using rule 65 (const -> TRUE .)
    MOD             reduce using rule 65 (const -> TRUE .)
    DIV             reduce using rule 65 (const -> TRUE .)
    =               reduce using rule 65 (const -> TRUE .)
    NOTEQUAL        reduce using rule 65 (const -> TRUE .)
    <               reduce using rule 65 (const -> TRUE .)
    >               reduce using rule 65 (const -> TRUE .)
    MINOREQUALS     reduce using rule 65 (const -> TRUE .)
    LARGEREQUALS    reduce using rule 65 (const -> TRUE .)
    +               reduce using rule 65 (const -> TRUE .)
    -               reduce using rule 65 (const -> TRUE .)
    OR              reduce using rule 65 (const -> TRUE .)
    THEN            reduce using rule 65 (const -> TRUE .)
    DO              reduce using rule 65 (const -> TRUE .)
    END             reduce using rule 65 (const -> TRUE .)
    BEGIN           reduce using rule 65 (const -> TRUE .)
    id              reduce using rule 65 (const -> TRUE .)
    IF              reduce using rule 65 (const -> TRUE .)
    WHILE           reduce using rule 65 (const -> TRUE .)
    FOR             reduce using rule 65 (const -> TRUE .)
    comment         reduce using rule 65 (const -> TRUE .)
    ELSE            reduce using rule 65 (const -> TRUE .)
    )               reduce using rule 65 (const -> TRUE .)
    ,               reduce using rule 65 (const -> TRUE .)
    ]               reduce using rule 65 (const -> TRUE .)
    TO              reduce using rule 65 (const -> TRUE .)
    DOWNTO          reduce using rule 65 (const -> TRUE .)


state 52

    (66) const -> FALSE .

    ;               reduce using rule 66 (const -> FALSE .)
    *               reduce using rule 66 (const -> FALSE .)
    /               reduce using rule 66 (const -> FALSE .)
    %               reduce using rule 66 (const -> FALSE .)
    AND             reduce using rule 66 (const -> FALSE .)
    MOD             reduce using rule 66 (const -> FALSE .)
    DIV             reduce using rule 66 (const -> FALSE .)
    =               reduce using rule 66 (const -> FALSE .)
    NOTEQUAL        reduce using rule 66 (const -> FALSE .)
    <               reduce using rule 66 (const -> FALSE .)
    >               reduce using rule 66 (const -> FALSE .)
    MINOREQUALS     reduce using rule 66 (const -> FALSE .)
    LARGEREQUALS    reduce using rule 66 (const -> FALSE .)
    +               reduce using rule 66 (const -> FALSE .)
    -               reduce using rule 66 (const -> FALSE .)
    OR              reduce using rule 66 (const -> FALSE .)
    THEN            reduce using rule 66 (const -> FALSE .)
    DO              reduce using rule 66 (const -> FALSE .)
    END             reduce using rule 66 (const -> FALSE .)
    BEGIN           reduce using rule 66 (const -> FALSE .)
    id              reduce using rule 66 (const -> FALSE .)
    IF              reduce using rule 66 (const -> FALSE .)
    WHILE           reduce using rule 66 (const -> FALSE .)
    FOR             reduce using rule 66 (const -> FALSE .)
    comment         reduce using rule 66 (const -> FALSE .)
    ELSE            reduce using rule 66 (const -> FALSE .)
    )               reduce using rule 66 (const -> FALSE .)
    ,               reduce using rule 66 (const -> FALSE .)
    ]               reduce using rule 66 (const -> FALSE .)
    TO              reduce using rule 66 (const -> FALSE .)
    DOWNTO          reduce using rule 66 (const -> FALSE .)


state 53

    (67) var -> id .
    (68) var -> id . [ expression ]
    (69) function_call -> id . ( ) terminator
    (70) function_call -> id . ( arg_list ) terminator

    ;               reduce using rule 67 (var -> id .)
    *               reduce using rule 67 (var -> id .)
    /               reduce using rule 67 (var -> id .)
    %               reduce using rule 67 (var -> id .)
    AND             reduce using rule 67 (var -> id .)
    MOD             reduce using rule 67 (var -> id .)
    DIV             reduce using rule 67 (var -> id .)
    =               reduce using rule 67 (var -> id .)
    NOTEQUAL        reduce using rule 67 (var -> id .)
    <               reduce using rule 67 (var -> id .)
    >               reduce using rule 67 (var -> id .)
    MINOREQUALS     reduce using rule 67 (var -> id .)
    LARGEREQUALS    reduce using rule 67 (var -> id .)
    +               reduce using rule 67 (var -> id .)
    -               reduce using rule 67 (var -> id .)
    OR              reduce using rule 67 (var -> id .)
    THEN            reduce using rule 67 (var -> id .)
    DO              reduce using rule 67 (var -> id .)
    END             reduce using rule 67 (var -> id .)
    BEGIN           reduce using rule 67 (var -> id .)
    id              reduce using rule 67 (var -> id .)
    IF              reduce using rule 67 (var -> id .)
    WHILE           reduce using rule 67 (var -> id .)
    FOR             reduce using rule 67 (var -> id .)
    comment         reduce using rule 67 (var -> id .)
    ELSE            reduce using rule 67 (var -> id .)
    )               reduce using rule 67 (var -> id .)
    ,               reduce using rule 67 (var -> id .)
    ]               reduce using rule 67 (var -> id .)
    TO              reduce using rule 67 (var -> id .)
    DOWNTO          reduce using rule 67 (var -> id .)
    [               shift and go to state 97
    (               shift and go to state 39


state 54

    (32) while_statement -> WHILE expression . DO statement
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    DO              shift and go to state 98
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 55

    (33) for_statement -> FOR id . ASSIGN expression forCont

    ASSIGN          shift and go to state 99


state 56

    (9) declaration_list -> declaration_list ; declaration .

    ;               reduce using rule 9 (declaration_list -> declaration_list ; declaration .)
    CONST           reduce using rule 9 (declaration_list -> declaration_list ; declaration .)
    VAR             reduce using rule 9 (declaration_list -> declaration_list ; declaration .)
    BEGIN           reduce using rule 9 (declaration_list -> declaration_list ; declaration .)


state 57

    (5) declarations -> VAR declaration_list CONST declaration_list .
    (9) declaration_list -> declaration_list . ; declaration

    BEGIN           reduce using rule 5 (declarations -> VAR declaration_list CONST declaration_list .)
    ;               shift and go to state 100


state 58

    (10) declaration -> id_list : type .

    ;               reduce using rule 10 (declaration -> id_list : type .)
    CONST           reduce using rule 10 (declaration -> id_list : type .)
    VAR             reduce using rule 10 (declaration -> id_list : type .)
    BEGIN           reduce using rule 10 (declaration -> id_list : type .)


state 59

    (13) type -> INTEGER .

    ;               reduce using rule 13 (type -> INTEGER .)
    CONST           reduce using rule 13 (type -> INTEGER .)
    VAR             reduce using rule 13 (type -> INTEGER .)
    BEGIN           reduce using rule 13 (type -> INTEGER .)


state 60

    (14) type -> REAL .

    ;               reduce using rule 14 (type -> REAL .)
    CONST           reduce using rule 14 (type -> REAL .)
    VAR             reduce using rule 14 (type -> REAL .)
    BEGIN           reduce using rule 14 (type -> REAL .)


state 61

    (15) type -> STRING .

    ;               reduce using rule 15 (type -> STRING .)
    CONST           reduce using rule 15 (type -> STRING .)
    VAR             reduce using rule 15 (type -> STRING .)
    BEGIN           reduce using rule 15 (type -> STRING .)


state 62

    (16) type -> CHAR .

    ;               reduce using rule 16 (type -> CHAR .)
    CONST           reduce using rule 16 (type -> CHAR .)
    VAR             reduce using rule 16 (type -> CHAR .)
    BEGIN           reduce using rule 16 (type -> CHAR .)


state 63

    (17) type -> BOOLEAN .

    ;               reduce using rule 17 (type -> BOOLEAN .)
    CONST           reduce using rule 17 (type -> BOOLEAN .)
    VAR             reduce using rule 17 (type -> BOOLEAN .)
    BEGIN           reduce using rule 17 (type -> BOOLEAN .)


state 64

    (18) type -> ARRAY . [ expression ] OF type

    [               shift and go to state 101


state 65

    (12) id_list -> id_list , id .

    :               reduce using rule 12 (id_list -> id_list , id .)
    ,               reduce using rule 12 (id_list -> id_list , id .)


state 66

    (6) declarations -> CONST declaration_list VAR declaration_list .
    (9) declaration_list -> declaration_list . ; declaration

    BEGIN           reduce using rule 6 (declarations -> CONST declaration_list VAR declaration_list .)
    ;               shift and go to state 100


state 67

    (2) block -> BEGIN statements END terminator .

    .               reduce using rule 2 (block -> BEGIN statements END terminator .)
    END             reduce using rule 2 (block -> BEGIN statements END terminator .)
    BEGIN           reduce using rule 2 (block -> BEGIN statements END terminator .)
    id              reduce using rule 2 (block -> BEGIN statements END terminator .)
    IF              reduce using rule 2 (block -> BEGIN statements END terminator .)
    WHILE           reduce using rule 2 (block -> BEGIN statements END terminator .)
    FOR             reduce using rule 2 (block -> BEGIN statements END terminator .)
    comment         reduce using rule 2 (block -> BEGIN statements END terminator .)
    ELSE            reduce using rule 2 (block -> BEGIN statements END terminator .)


state 68

    (71) terminator -> ; .

    .               reduce using rule 71 (terminator -> ; .)
    END             reduce using rule 71 (terminator -> ; .)
    BEGIN           reduce using rule 71 (terminator -> ; .)
    id              reduce using rule 71 (terminator -> ; .)
    IF              reduce using rule 71 (terminator -> ; .)
    WHILE           reduce using rule 71 (terminator -> ; .)
    FOR             reduce using rule 71 (terminator -> ; .)
    comment         reduce using rule 71 (terminator -> ; .)
    ELSE            reduce using rule 71 (terminator -> ; .)
    *               reduce using rule 71 (terminator -> ; .)
    /               reduce using rule 71 (terminator -> ; .)
    %               reduce using rule 71 (terminator -> ; .)
    AND             reduce using rule 71 (terminator -> ; .)
    MOD             reduce using rule 71 (terminator -> ; .)
    DIV             reduce using rule 71 (terminator -> ; .)
    =               reduce using rule 71 (terminator -> ; .)
    NOTEQUAL        reduce using rule 71 (terminator -> ; .)
    <               reduce using rule 71 (terminator -> ; .)
    >               reduce using rule 71 (terminator -> ; .)
    MINOREQUALS     reduce using rule 71 (terminator -> ; .)
    LARGEREQUALS    reduce using rule 71 (terminator -> ; .)
    +               reduce using rule 71 (terminator -> ; .)
    -               reduce using rule 71 (terminator -> ; .)
    OR              reduce using rule 71 (terminator -> ; .)
    THEN            reduce using rule 71 (terminator -> ; .)
    DO              reduce using rule 71 (terminator -> ; .)
    )               reduce using rule 71 (terminator -> ; .)
    ,               reduce using rule 71 (terminator -> ; .)
    ]               reduce using rule 71 (terminator -> ; .)
    TO              reduce using rule 71 (terminator -> ; .)
    DOWNTO          reduce using rule 71 (terminator -> ; .)


state 69

    (28) assignment -> id ASSIGN expression .
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    END             reduce using rule 28 (assignment -> id ASSIGN expression .)
    BEGIN           reduce using rule 28 (assignment -> id ASSIGN expression .)
    id              reduce using rule 28 (assignment -> id ASSIGN expression .)
    IF              reduce using rule 28 (assignment -> id ASSIGN expression .)
    WHILE           reduce using rule 28 (assignment -> id ASSIGN expression .)
    FOR             reduce using rule 28 (assignment -> id ASSIGN expression .)
    comment         reduce using rule 28 (assignment -> id ASSIGN expression .)
    ELSE            reduce using rule 28 (assignment -> id ASSIGN expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 70

    (69) function_call -> id ( ) . terminator
    (71) terminator -> . ;
    (72) terminator -> .

    ;               shift and go to state 68
    END             reduce using rule 72 (terminator -> .)
    BEGIN           reduce using rule 72 (terminator -> .)
    id              reduce using rule 72 (terminator -> .)
    IF              reduce using rule 72 (terminator -> .)
    WHILE           reduce using rule 72 (terminator -> .)
    FOR             reduce using rule 72 (terminator -> .)
    comment         reduce using rule 72 (terminator -> .)
    *               reduce using rule 72 (terminator -> .)
    /               reduce using rule 72 (terminator -> .)
    %               reduce using rule 72 (terminator -> .)
    AND             reduce using rule 72 (terminator -> .)
    MOD             reduce using rule 72 (terminator -> .)
    DIV             reduce using rule 72 (terminator -> .)
    =               reduce using rule 72 (terminator -> .)
    NOTEQUAL        reduce using rule 72 (terminator -> .)
    <               reduce using rule 72 (terminator -> .)
    >               reduce using rule 72 (terminator -> .)
    MINOREQUALS     reduce using rule 72 (terminator -> .)
    LARGEREQUALS    reduce using rule 72 (terminator -> .)
    +               reduce using rule 72 (terminator -> .)
    -               reduce using rule 72 (terminator -> .)
    OR              reduce using rule 72 (terminator -> .)
    THEN            reduce using rule 72 (terminator -> .)
    DO              reduce using rule 72 (terminator -> .)
    ELSE            reduce using rule 72 (terminator -> .)
    )               reduce using rule 72 (terminator -> .)
    ,               reduce using rule 72 (terminator -> .)
    ]               reduce using rule 72 (terminator -> .)
    TO              reduce using rule 72 (terminator -> .)
    DOWNTO          reduce using rule 72 (terminator -> .)

    terminator                     shift and go to state 102

state 71

    (70) function_call -> id ( arg_list . ) terminator
    (74) arg_list -> arg_list . , expression

    )               shift and go to state 103
    ,               shift and go to state 104


state 72

    (73) arg_list -> expression .
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    )               reduce using rule 73 (arg_list -> expression .)
    ,               reduce using rule 73 (arg_list -> expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 73

    (29) if_statement -> IF exprBool THEN . statement ifCont
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 105
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 74

    (37) exprBool -> expression opRel . expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 106
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 75

    (46) expression -> expression opAdd . term
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    (               shift and go to state 49
    num             shift and go to state 108
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    term                           shift and go to state 107
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 76

    (39) opRel -> = .

    num             reduce using rule 39 (opRel -> = .)
    (               reduce using rule 39 (opRel -> = .)
    text            reduce using rule 39 (opRel -> = .)
    TRUE            reduce using rule 39 (opRel -> = .)
    FALSE           reduce using rule 39 (opRel -> = .)
    id              reduce using rule 39 (opRel -> = .)


state 77

    (40) opRel -> NOTEQUAL .

    num             reduce using rule 40 (opRel -> NOTEQUAL .)
    (               reduce using rule 40 (opRel -> NOTEQUAL .)
    text            reduce using rule 40 (opRel -> NOTEQUAL .)
    TRUE            reduce using rule 40 (opRel -> NOTEQUAL .)
    FALSE           reduce using rule 40 (opRel -> NOTEQUAL .)
    id              reduce using rule 40 (opRel -> NOTEQUAL .)


state 78

    (41) opRel -> < .

    num             reduce using rule 41 (opRel -> < .)
    (               reduce using rule 41 (opRel -> < .)
    text            reduce using rule 41 (opRel -> < .)
    TRUE            reduce using rule 41 (opRel -> < .)
    FALSE           reduce using rule 41 (opRel -> < .)
    id              reduce using rule 41 (opRel -> < .)


state 79

    (42) opRel -> > .

    num             reduce using rule 42 (opRel -> > .)
    (               reduce using rule 42 (opRel -> > .)
    text            reduce using rule 42 (opRel -> > .)
    TRUE            reduce using rule 42 (opRel -> > .)
    FALSE           reduce using rule 42 (opRel -> > .)
    id              reduce using rule 42 (opRel -> > .)


state 80

    (43) opRel -> MINOREQUALS .

    num             reduce using rule 43 (opRel -> MINOREQUALS .)
    (               reduce using rule 43 (opRel -> MINOREQUALS .)
    text            reduce using rule 43 (opRel -> MINOREQUALS .)
    TRUE            reduce using rule 43 (opRel -> MINOREQUALS .)
    FALSE           reduce using rule 43 (opRel -> MINOREQUALS .)
    id              reduce using rule 43 (opRel -> MINOREQUALS .)


state 81

    (44) opRel -> LARGEREQUALS .

    num             reduce using rule 44 (opRel -> LARGEREQUALS .)
    (               reduce using rule 44 (opRel -> LARGEREQUALS .)
    text            reduce using rule 44 (opRel -> LARGEREQUALS .)
    TRUE            reduce using rule 44 (opRel -> LARGEREQUALS .)
    FALSE           reduce using rule 44 (opRel -> LARGEREQUALS .)
    id              reduce using rule 44 (opRel -> LARGEREQUALS .)


state 82

    (48) opAdd -> + .

    (               reduce using rule 48 (opAdd -> + .)
    num             reduce using rule 48 (opAdd -> + .)
    text            reduce using rule 48 (opAdd -> + .)
    TRUE            reduce using rule 48 (opAdd -> + .)
    FALSE           reduce using rule 48 (opAdd -> + .)
    id              reduce using rule 48 (opAdd -> + .)


state 83

    (49) opAdd -> - .

    (               reduce using rule 49 (opAdd -> - .)
    num             reduce using rule 49 (opAdd -> - .)
    text            reduce using rule 49 (opAdd -> - .)
    TRUE            reduce using rule 49 (opAdd -> - .)
    FALSE           reduce using rule 49 (opAdd -> - .)
    id              reduce using rule 49 (opAdd -> - .)


state 84

    (50) opAdd -> OR .

    (               reduce using rule 50 (opAdd -> OR .)
    num             reduce using rule 50 (opAdd -> OR .)
    text            reduce using rule 50 (opAdd -> OR .)
    TRUE            reduce using rule 50 (opAdd -> OR .)
    FALSE           reduce using rule 50 (opAdd -> OR .)
    id              reduce using rule 50 (opAdd -> OR .)


state 85

    (38) exprBool -> NOT expression .
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    THEN            reduce using rule 38 (exprBool -> NOT expression .)
    )               reduce using rule 38 (exprBool -> NOT expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 86

    (52) term -> term opMul . factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    (               shift and go to state 49
    num             shift and go to state 108
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    factor                         shift and go to state 109
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 87

    (53) opMul -> * .

    (               reduce using rule 53 (opMul -> * .)
    num             reduce using rule 53 (opMul -> * .)
    text            reduce using rule 53 (opMul -> * .)
    TRUE            reduce using rule 53 (opMul -> * .)
    FALSE           reduce using rule 53 (opMul -> * .)
    id              reduce using rule 53 (opMul -> * .)


state 88

    (54) opMul -> / .

    (               reduce using rule 54 (opMul -> / .)
    num             reduce using rule 54 (opMul -> / .)
    text            reduce using rule 54 (opMul -> / .)
    TRUE            reduce using rule 54 (opMul -> / .)
    FALSE           reduce using rule 54 (opMul -> / .)
    id              reduce using rule 54 (opMul -> / .)


state 89

    (55) opMul -> % .

    (               reduce using rule 55 (opMul -> % .)
    num             reduce using rule 55 (opMul -> % .)
    text            reduce using rule 55 (opMul -> % .)
    TRUE            reduce using rule 55 (opMul -> % .)
    FALSE           reduce using rule 55 (opMul -> % .)
    id              reduce using rule 55 (opMul -> % .)


state 90

    (56) opMul -> AND .

    (               reduce using rule 56 (opMul -> AND .)
    num             reduce using rule 56 (opMul -> AND .)
    text            reduce using rule 56 (opMul -> AND .)
    TRUE            reduce using rule 56 (opMul -> AND .)
    FALSE           reduce using rule 56 (opMul -> AND .)
    id              reduce using rule 56 (opMul -> AND .)


state 91

    (57) opMul -> MOD .

    (               reduce using rule 57 (opMul -> MOD .)
    num             reduce using rule 57 (opMul -> MOD .)
    text            reduce using rule 57 (opMul -> MOD .)
    TRUE            reduce using rule 57 (opMul -> MOD .)
    FALSE           reduce using rule 57 (opMul -> MOD .)
    id              reduce using rule 57 (opMul -> MOD .)


state 92

    (58) opMul -> DIV .

    (               reduce using rule 58 (opMul -> DIV .)
    num             reduce using rule 58 (opMul -> DIV .)
    text            reduce using rule 58 (opMul -> DIV .)
    TRUE            reduce using rule 58 (opMul -> DIV .)
    FALSE           reduce using rule 58 (opMul -> DIV .)
    id              reduce using rule 58 (opMul -> DIV .)


state 93

    (47) expression -> num TWODOTS . num

    num             shift and go to state 110


state 94

    (59) factor -> const terminator .

    *               reduce using rule 59 (factor -> const terminator .)
    /               reduce using rule 59 (factor -> const terminator .)
    %               reduce using rule 59 (factor -> const terminator .)
    AND             reduce using rule 59 (factor -> const terminator .)
    MOD             reduce using rule 59 (factor -> const terminator .)
    DIV             reduce using rule 59 (factor -> const terminator .)
    =               reduce using rule 59 (factor -> const terminator .)
    NOTEQUAL        reduce using rule 59 (factor -> const terminator .)
    <               reduce using rule 59 (factor -> const terminator .)
    >               reduce using rule 59 (factor -> const terminator .)
    MINOREQUALS     reduce using rule 59 (factor -> const terminator .)
    LARGEREQUALS    reduce using rule 59 (factor -> const terminator .)
    +               reduce using rule 59 (factor -> const terminator .)
    -               reduce using rule 59 (factor -> const terminator .)
    OR              reduce using rule 59 (factor -> const terminator .)
    THEN            reduce using rule 59 (factor -> const terminator .)
    DO              reduce using rule 59 (factor -> const terminator .)
    END             reduce using rule 59 (factor -> const terminator .)
    BEGIN           reduce using rule 59 (factor -> const terminator .)
    id              reduce using rule 59 (factor -> const terminator .)
    IF              reduce using rule 59 (factor -> const terminator .)
    WHILE           reduce using rule 59 (factor -> const terminator .)
    FOR             reduce using rule 59 (factor -> const terminator .)
    comment         reduce using rule 59 (factor -> const terminator .)
    ELSE            reduce using rule 59 (factor -> const terminator .)
    )               reduce using rule 59 (factor -> const terminator .)
    ,               reduce using rule 59 (factor -> const terminator .)
    ]               reduce using rule 59 (factor -> const terminator .)
    TO              reduce using rule 59 (factor -> const terminator .)
    DOWNTO          reduce using rule 59 (factor -> const terminator .)


state 95

    (60) factor -> var terminator .

    *               reduce using rule 60 (factor -> var terminator .)
    /               reduce using rule 60 (factor -> var terminator .)
    %               reduce using rule 60 (factor -> var terminator .)
    AND             reduce using rule 60 (factor -> var terminator .)
    MOD             reduce using rule 60 (factor -> var terminator .)
    DIV             reduce using rule 60 (factor -> var terminator .)
    =               reduce using rule 60 (factor -> var terminator .)
    NOTEQUAL        reduce using rule 60 (factor -> var terminator .)
    <               reduce using rule 60 (factor -> var terminator .)
    >               reduce using rule 60 (factor -> var terminator .)
    MINOREQUALS     reduce using rule 60 (factor -> var terminator .)
    LARGEREQUALS    reduce using rule 60 (factor -> var terminator .)
    +               reduce using rule 60 (factor -> var terminator .)
    -               reduce using rule 60 (factor -> var terminator .)
    OR              reduce using rule 60 (factor -> var terminator .)
    THEN            reduce using rule 60 (factor -> var terminator .)
    DO              reduce using rule 60 (factor -> var terminator .)
    END             reduce using rule 60 (factor -> var terminator .)
    BEGIN           reduce using rule 60 (factor -> var terminator .)
    id              reduce using rule 60 (factor -> var terminator .)
    IF              reduce using rule 60 (factor -> var terminator .)
    WHILE           reduce using rule 60 (factor -> var terminator .)
    FOR             reduce using rule 60 (factor -> var terminator .)
    comment         reduce using rule 60 (factor -> var terminator .)
    ELSE            reduce using rule 60 (factor -> var terminator .)
    )               reduce using rule 60 (factor -> var terminator .)
    ,               reduce using rule 60 (factor -> var terminator .)
    ]               reduce using rule 60 (factor -> var terminator .)
    TO              reduce using rule 60 (factor -> var terminator .)
    DOWNTO          reduce using rule 60 (factor -> var terminator .)


state 96

    (62) factor -> ( exprBool . )

    )               shift and go to state 111


state 97

    (68) var -> id [ . expression ]
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 112
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 98

    (32) while_statement -> WHILE expression DO . statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 113
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 99

    (33) for_statement -> FOR id ASSIGN . expression forCont
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 114
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 100

    (9) declaration_list -> declaration_list ; . declaration
    (10) declaration -> . id_list : type
    (11) id_list -> . id
    (12) id_list -> . id_list , id

    id              shift and go to state 13

    declaration                    shift and go to state 56
    id_list                        shift and go to state 12

state 101

    (18) type -> ARRAY [ . expression ] OF type
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 115
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 102

    (69) function_call -> id ( ) terminator .

    END             reduce using rule 69 (function_call -> id ( ) terminator .)
    BEGIN           reduce using rule 69 (function_call -> id ( ) terminator .)
    id              reduce using rule 69 (function_call -> id ( ) terminator .)
    IF              reduce using rule 69 (function_call -> id ( ) terminator .)
    WHILE           reduce using rule 69 (function_call -> id ( ) terminator .)
    FOR             reduce using rule 69 (function_call -> id ( ) terminator .)
    comment         reduce using rule 69 (function_call -> id ( ) terminator .)
    *               reduce using rule 69 (function_call -> id ( ) terminator .)
    /               reduce using rule 69 (function_call -> id ( ) terminator .)
    %               reduce using rule 69 (function_call -> id ( ) terminator .)
    AND             reduce using rule 69 (function_call -> id ( ) terminator .)
    MOD             reduce using rule 69 (function_call -> id ( ) terminator .)
    DIV             reduce using rule 69 (function_call -> id ( ) terminator .)
    =               reduce using rule 69 (function_call -> id ( ) terminator .)
    NOTEQUAL        reduce using rule 69 (function_call -> id ( ) terminator .)
    <               reduce using rule 69 (function_call -> id ( ) terminator .)
    >               reduce using rule 69 (function_call -> id ( ) terminator .)
    MINOREQUALS     reduce using rule 69 (function_call -> id ( ) terminator .)
    LARGEREQUALS    reduce using rule 69 (function_call -> id ( ) terminator .)
    +               reduce using rule 69 (function_call -> id ( ) terminator .)
    -               reduce using rule 69 (function_call -> id ( ) terminator .)
    OR              reduce using rule 69 (function_call -> id ( ) terminator .)
    THEN            reduce using rule 69 (function_call -> id ( ) terminator .)
    DO              reduce using rule 69 (function_call -> id ( ) terminator .)
    ELSE            reduce using rule 69 (function_call -> id ( ) terminator .)
    )               reduce using rule 69 (function_call -> id ( ) terminator .)
    ,               reduce using rule 69 (function_call -> id ( ) terminator .)
    ]               reduce using rule 69 (function_call -> id ( ) terminator .)
    TO              reduce using rule 69 (function_call -> id ( ) terminator .)
    DOWNTO          reduce using rule 69 (function_call -> id ( ) terminator .)


state 103

    (70) function_call -> id ( arg_list ) . terminator
    (71) terminator -> . ;
    (72) terminator -> .

    ;               shift and go to state 68
    END             reduce using rule 72 (terminator -> .)
    BEGIN           reduce using rule 72 (terminator -> .)
    id              reduce using rule 72 (terminator -> .)
    IF              reduce using rule 72 (terminator -> .)
    WHILE           reduce using rule 72 (terminator -> .)
    FOR             reduce using rule 72 (terminator -> .)
    comment         reduce using rule 72 (terminator -> .)
    *               reduce using rule 72 (terminator -> .)
    /               reduce using rule 72 (terminator -> .)
    %               reduce using rule 72 (terminator -> .)
    AND             reduce using rule 72 (terminator -> .)
    MOD             reduce using rule 72 (terminator -> .)
    DIV             reduce using rule 72 (terminator -> .)
    =               reduce using rule 72 (terminator -> .)
    NOTEQUAL        reduce using rule 72 (terminator -> .)
    <               reduce using rule 72 (terminator -> .)
    >               reduce using rule 72 (terminator -> .)
    MINOREQUALS     reduce using rule 72 (terminator -> .)
    LARGEREQUALS    reduce using rule 72 (terminator -> .)
    +               reduce using rule 72 (terminator -> .)
    -               reduce using rule 72 (terminator -> .)
    OR              reduce using rule 72 (terminator -> .)
    THEN            reduce using rule 72 (terminator -> .)
    DO              reduce using rule 72 (terminator -> .)
    ELSE            reduce using rule 72 (terminator -> .)
    )               reduce using rule 72 (terminator -> .)
    ,               reduce using rule 72 (terminator -> .)
    ]               reduce using rule 72 (terminator -> .)
    TO              reduce using rule 72 (terminator -> .)
    DOWNTO          reduce using rule 72 (terminator -> .)

    terminator                     shift and go to state 116

state 104

    (74) arg_list -> arg_list , . expression
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 117
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 105

    (29) if_statement -> IF exprBool THEN statement . ifCont
    (30) ifCont -> .
    (31) ifCont -> . ELSE statement

  ! shift/reduce conflict for ELSE resolved as shift
    END             reduce using rule 30 (ifCont -> .)
    BEGIN           reduce using rule 30 (ifCont -> .)
    id              reduce using rule 30 (ifCont -> .)
    IF              reduce using rule 30 (ifCont -> .)
    WHILE           reduce using rule 30 (ifCont -> .)
    FOR             reduce using rule 30 (ifCont -> .)
    comment         reduce using rule 30 (ifCont -> .)
    ELSE            shift and go to state 119

  ! ELSE            [ reduce using rule 30 (ifCont -> .) ]

    ifCont                         shift and go to state 118

state 106

    (37) exprBool -> expression opRel expression .
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    THEN            reduce using rule 37 (exprBool -> expression opRel expression .)
    )               reduce using rule 37 (exprBool -> expression opRel expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 107

    (46) expression -> expression opAdd term .
    (52) term -> term . opMul factor
    (53) opMul -> . *
    (54) opMul -> . /
    (55) opMul -> . %
    (56) opMul -> . AND
    (57) opMul -> . MOD
    (58) opMul -> . DIV

    =               reduce using rule 46 (expression -> expression opAdd term .)
    NOTEQUAL        reduce using rule 46 (expression -> expression opAdd term .)
    <               reduce using rule 46 (expression -> expression opAdd term .)
    >               reduce using rule 46 (expression -> expression opAdd term .)
    MINOREQUALS     reduce using rule 46 (expression -> expression opAdd term .)
    LARGEREQUALS    reduce using rule 46 (expression -> expression opAdd term .)
    +               reduce using rule 46 (expression -> expression opAdd term .)
    -               reduce using rule 46 (expression -> expression opAdd term .)
    OR              reduce using rule 46 (expression -> expression opAdd term .)
    THEN            reduce using rule 46 (expression -> expression opAdd term .)
    DO              reduce using rule 46 (expression -> expression opAdd term .)
    END             reduce using rule 46 (expression -> expression opAdd term .)
    BEGIN           reduce using rule 46 (expression -> expression opAdd term .)
    id              reduce using rule 46 (expression -> expression opAdd term .)
    IF              reduce using rule 46 (expression -> expression opAdd term .)
    WHILE           reduce using rule 46 (expression -> expression opAdd term .)
    FOR             reduce using rule 46 (expression -> expression opAdd term .)
    comment         reduce using rule 46 (expression -> expression opAdd term .)
    ELSE            reduce using rule 46 (expression -> expression opAdd term .)
    )               reduce using rule 46 (expression -> expression opAdd term .)
    ,               reduce using rule 46 (expression -> expression opAdd term .)
    ]               reduce using rule 46 (expression -> expression opAdd term .)
    TO              reduce using rule 46 (expression -> expression opAdd term .)
    DOWNTO          reduce using rule 46 (expression -> expression opAdd term .)
    *               shift and go to state 87
    /               shift and go to state 88
    %               shift and go to state 89
    AND             shift and go to state 90
    MOD             shift and go to state 91
    DIV             shift and go to state 92

    opMul                          shift and go to state 86

state 108

    (63) const -> num .

    ;               reduce using rule 63 (const -> num .)
    *               reduce using rule 63 (const -> num .)
    /               reduce using rule 63 (const -> num .)
    %               reduce using rule 63 (const -> num .)
    AND             reduce using rule 63 (const -> num .)
    MOD             reduce using rule 63 (const -> num .)
    DIV             reduce using rule 63 (const -> num .)
    =               reduce using rule 63 (const -> num .)
    NOTEQUAL        reduce using rule 63 (const -> num .)
    <               reduce using rule 63 (const -> num .)
    >               reduce using rule 63 (const -> num .)
    MINOREQUALS     reduce using rule 63 (const -> num .)
    LARGEREQUALS    reduce using rule 63 (const -> num .)
    +               reduce using rule 63 (const -> num .)
    -               reduce using rule 63 (const -> num .)
    OR              reduce using rule 63 (const -> num .)
    THEN            reduce using rule 63 (const -> num .)
    DO              reduce using rule 63 (const -> num .)
    END             reduce using rule 63 (const -> num .)
    BEGIN           reduce using rule 63 (const -> num .)
    id              reduce using rule 63 (const -> num .)
    IF              reduce using rule 63 (const -> num .)
    WHILE           reduce using rule 63 (const -> num .)
    FOR             reduce using rule 63 (const -> num .)
    comment         reduce using rule 63 (const -> num .)
    ELSE            reduce using rule 63 (const -> num .)
    )               reduce using rule 63 (const -> num .)
    ,               reduce using rule 63 (const -> num .)
    ]               reduce using rule 63 (const -> num .)
    TO              reduce using rule 63 (const -> num .)
    DOWNTO          reduce using rule 63 (const -> num .)


state 109

    (52) term -> term opMul factor .

    *               reduce using rule 52 (term -> term opMul factor .)
    /               reduce using rule 52 (term -> term opMul factor .)
    %               reduce using rule 52 (term -> term opMul factor .)
    AND             reduce using rule 52 (term -> term opMul factor .)
    MOD             reduce using rule 52 (term -> term opMul factor .)
    DIV             reduce using rule 52 (term -> term opMul factor .)
    =               reduce using rule 52 (term -> term opMul factor .)
    NOTEQUAL        reduce using rule 52 (term -> term opMul factor .)
    <               reduce using rule 52 (term -> term opMul factor .)
    >               reduce using rule 52 (term -> term opMul factor .)
    MINOREQUALS     reduce using rule 52 (term -> term opMul factor .)
    LARGEREQUALS    reduce using rule 52 (term -> term opMul factor .)
    +               reduce using rule 52 (term -> term opMul factor .)
    -               reduce using rule 52 (term -> term opMul factor .)
    OR              reduce using rule 52 (term -> term opMul factor .)
    THEN            reduce using rule 52 (term -> term opMul factor .)
    DO              reduce using rule 52 (term -> term opMul factor .)
    END             reduce using rule 52 (term -> term opMul factor .)
    BEGIN           reduce using rule 52 (term -> term opMul factor .)
    id              reduce using rule 52 (term -> term opMul factor .)
    IF              reduce using rule 52 (term -> term opMul factor .)
    WHILE           reduce using rule 52 (term -> term opMul factor .)
    FOR             reduce using rule 52 (term -> term opMul factor .)
    comment         reduce using rule 52 (term -> term opMul factor .)
    ELSE            reduce using rule 52 (term -> term opMul factor .)
    )               reduce using rule 52 (term -> term opMul factor .)
    ,               reduce using rule 52 (term -> term opMul factor .)
    ]               reduce using rule 52 (term -> term opMul factor .)
    TO              reduce using rule 52 (term -> term opMul factor .)
    DOWNTO          reduce using rule 52 (term -> term opMul factor .)


state 110

    (47) expression -> num TWODOTS num .

    =               reduce using rule 47 (expression -> num TWODOTS num .)
    NOTEQUAL        reduce using rule 47 (expression -> num TWODOTS num .)
    <               reduce using rule 47 (expression -> num TWODOTS num .)
    >               reduce using rule 47 (expression -> num TWODOTS num .)
    MINOREQUALS     reduce using rule 47 (expression -> num TWODOTS num .)
    LARGEREQUALS    reduce using rule 47 (expression -> num TWODOTS num .)
    +               reduce using rule 47 (expression -> num TWODOTS num .)
    -               reduce using rule 47 (expression -> num TWODOTS num .)
    OR              reduce using rule 47 (expression -> num TWODOTS num .)
    THEN            reduce using rule 47 (expression -> num TWODOTS num .)
    DO              reduce using rule 47 (expression -> num TWODOTS num .)
    END             reduce using rule 47 (expression -> num TWODOTS num .)
    BEGIN           reduce using rule 47 (expression -> num TWODOTS num .)
    id              reduce using rule 47 (expression -> num TWODOTS num .)
    IF              reduce using rule 47 (expression -> num TWODOTS num .)
    WHILE           reduce using rule 47 (expression -> num TWODOTS num .)
    FOR             reduce using rule 47 (expression -> num TWODOTS num .)
    comment         reduce using rule 47 (expression -> num TWODOTS num .)
    ELSE            reduce using rule 47 (expression -> num TWODOTS num .)
    )               reduce using rule 47 (expression -> num TWODOTS num .)
    ,               reduce using rule 47 (expression -> num TWODOTS num .)
    ]               reduce using rule 47 (expression -> num TWODOTS num .)
    TO              reduce using rule 47 (expression -> num TWODOTS num .)
    DOWNTO          reduce using rule 47 (expression -> num TWODOTS num .)


state 111

    (62) factor -> ( exprBool ) .

    *               reduce using rule 62 (factor -> ( exprBool ) .)
    /               reduce using rule 62 (factor -> ( exprBool ) .)
    %               reduce using rule 62 (factor -> ( exprBool ) .)
    AND             reduce using rule 62 (factor -> ( exprBool ) .)
    MOD             reduce using rule 62 (factor -> ( exprBool ) .)
    DIV             reduce using rule 62 (factor -> ( exprBool ) .)
    =               reduce using rule 62 (factor -> ( exprBool ) .)
    NOTEQUAL        reduce using rule 62 (factor -> ( exprBool ) .)
    <               reduce using rule 62 (factor -> ( exprBool ) .)
    >               reduce using rule 62 (factor -> ( exprBool ) .)
    MINOREQUALS     reduce using rule 62 (factor -> ( exprBool ) .)
    LARGEREQUALS    reduce using rule 62 (factor -> ( exprBool ) .)
    +               reduce using rule 62 (factor -> ( exprBool ) .)
    -               reduce using rule 62 (factor -> ( exprBool ) .)
    OR              reduce using rule 62 (factor -> ( exprBool ) .)
    THEN            reduce using rule 62 (factor -> ( exprBool ) .)
    DO              reduce using rule 62 (factor -> ( exprBool ) .)
    END             reduce using rule 62 (factor -> ( exprBool ) .)
    BEGIN           reduce using rule 62 (factor -> ( exprBool ) .)
    id              reduce using rule 62 (factor -> ( exprBool ) .)
    IF              reduce using rule 62 (factor -> ( exprBool ) .)
    WHILE           reduce using rule 62 (factor -> ( exprBool ) .)
    FOR             reduce using rule 62 (factor -> ( exprBool ) .)
    comment         reduce using rule 62 (factor -> ( exprBool ) .)
    ELSE            reduce using rule 62 (factor -> ( exprBool ) .)
    )               reduce using rule 62 (factor -> ( exprBool ) .)
    ,               reduce using rule 62 (factor -> ( exprBool ) .)
    ]               reduce using rule 62 (factor -> ( exprBool ) .)
    TO              reduce using rule 62 (factor -> ( exprBool ) .)
    DOWNTO          reduce using rule 62 (factor -> ( exprBool ) .)


state 112

    (68) var -> id [ expression . ]
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    ]               shift and go to state 120
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 113

    (32) while_statement -> WHILE expression DO statement .

    END             reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    BEGIN           reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    id              reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    IF              reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    WHILE           reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    FOR             reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    comment         reduce using rule 32 (while_statement -> WHILE expression DO statement .)
    ELSE            reduce using rule 32 (while_statement -> WHILE expression DO statement .)


state 114

    (33) for_statement -> FOR id ASSIGN expression . forCont
    (46) expression -> expression . opAdd term
    (34) forCont -> . TO expression DO statement
    (35) forCont -> . DOWNTO expression DO statement
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    TO              shift and go to state 122
    DOWNTO          shift and go to state 123
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    forCont                        shift and go to state 121
    opAdd                          shift and go to state 75

state 115

    (18) type -> ARRAY [ expression . ] OF type
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    ]               shift and go to state 124
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 116

    (70) function_call -> id ( arg_list ) terminator .

    END             reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    BEGIN           reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    id              reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    IF              reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    WHILE           reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    FOR             reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    comment         reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    *               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    /               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    %               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    AND             reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    MOD             reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    DIV             reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    =               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    NOTEQUAL        reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    <               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    >               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    MINOREQUALS     reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    LARGEREQUALS    reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    +               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    -               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    OR              reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    THEN            reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    DO              reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    ELSE            reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    )               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    ,               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    ]               reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    TO              reduce using rule 70 (function_call -> id ( arg_list ) terminator .)
    DOWNTO          reduce using rule 70 (function_call -> id ( arg_list ) terminator .)


state 117

    (74) arg_list -> arg_list , expression .
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    )               reduce using rule 74 (arg_list -> arg_list , expression .)
    ,               reduce using rule 74 (arg_list -> arg_list , expression .)
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 118

    (29) if_statement -> IF exprBool THEN statement ifCont .

    END             reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    BEGIN           reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    id              reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    IF              reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    WHILE           reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    FOR             reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    comment         reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)
    ELSE            reduce using rule 29 (if_statement -> IF exprBool THEN statement ifCont .)


state 119

    (31) ifCont -> ELSE . statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 125
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 120

    (68) var -> id [ expression ] .

    ;               reduce using rule 68 (var -> id [ expression ] .)
    *               reduce using rule 68 (var -> id [ expression ] .)
    /               reduce using rule 68 (var -> id [ expression ] .)
    %               reduce using rule 68 (var -> id [ expression ] .)
    AND             reduce using rule 68 (var -> id [ expression ] .)
    MOD             reduce using rule 68 (var -> id [ expression ] .)
    DIV             reduce using rule 68 (var -> id [ expression ] .)
    =               reduce using rule 68 (var -> id [ expression ] .)
    NOTEQUAL        reduce using rule 68 (var -> id [ expression ] .)
    <               reduce using rule 68 (var -> id [ expression ] .)
    >               reduce using rule 68 (var -> id [ expression ] .)
    MINOREQUALS     reduce using rule 68 (var -> id [ expression ] .)
    LARGEREQUALS    reduce using rule 68 (var -> id [ expression ] .)
    +               reduce using rule 68 (var -> id [ expression ] .)
    -               reduce using rule 68 (var -> id [ expression ] .)
    OR              reduce using rule 68 (var -> id [ expression ] .)
    THEN            reduce using rule 68 (var -> id [ expression ] .)
    DO              reduce using rule 68 (var -> id [ expression ] .)
    END             reduce using rule 68 (var -> id [ expression ] .)
    BEGIN           reduce using rule 68 (var -> id [ expression ] .)
    id              reduce using rule 68 (var -> id [ expression ] .)
    IF              reduce using rule 68 (var -> id [ expression ] .)
    WHILE           reduce using rule 68 (var -> id [ expression ] .)
    FOR             reduce using rule 68 (var -> id [ expression ] .)
    comment         reduce using rule 68 (var -> id [ expression ] .)
    ELSE            reduce using rule 68 (var -> id [ expression ] .)
    )               reduce using rule 68 (var -> id [ expression ] .)
    ,               reduce using rule 68 (var -> id [ expression ] .)
    ]               reduce using rule 68 (var -> id [ expression ] .)
    TO              reduce using rule 68 (var -> id [ expression ] .)
    DOWNTO          reduce using rule 68 (var -> id [ expression ] .)


state 121

    (33) for_statement -> FOR id ASSIGN expression forCont .

    END             reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    BEGIN           reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    id              reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    IF              reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    WHILE           reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    FOR             reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    comment         reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)
    ELSE            reduce using rule 33 (for_statement -> FOR id ASSIGN expression forCont .)


state 122

    (34) forCont -> TO . expression DO statement
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 126
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 123

    (35) forCont -> DOWNTO . expression DO statement
    (45) expression -> . term
    (46) expression -> . expression opAdd term
    (47) expression -> . num TWODOTS num
    (51) term -> . factor
    (52) term -> . term opMul factor
    (59) factor -> . const terminator
    (60) factor -> . var terminator
    (61) factor -> . function_call
    (62) factor -> . ( exprBool )
    (63) const -> . num
    (64) const -> . text
    (65) const -> . TRUE
    (66) const -> . FALSE
    (67) var -> . id
    (68) var -> . id [ expression ]
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    num             shift and go to state 44
    (               shift and go to state 49
    text            shift and go to state 50
    TRUE            shift and go to state 51
    FALSE           shift and go to state 52
    id              shift and go to state 53

    expression                     shift and go to state 127
    term                           shift and go to state 43
    factor                         shift and go to state 45
    const                          shift and go to state 46
    var                            shift and go to state 47
    function_call                  shift and go to state 48

state 124

    (18) type -> ARRAY [ expression ] . OF type

    OF              shift and go to state 128


state 125

    (31) ifCont -> ELSE statement .

    ELSE            reduce using rule 31 (ifCont -> ELSE statement .)
    END             reduce using rule 31 (ifCont -> ELSE statement .)
    BEGIN           reduce using rule 31 (ifCont -> ELSE statement .)
    id              reduce using rule 31 (ifCont -> ELSE statement .)
    IF              reduce using rule 31 (ifCont -> ELSE statement .)
    WHILE           reduce using rule 31 (ifCont -> ELSE statement .)
    FOR             reduce using rule 31 (ifCont -> ELSE statement .)
    comment         reduce using rule 31 (ifCont -> ELSE statement .)


state 126

    (34) forCont -> TO expression . DO statement
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    DO              shift and go to state 129
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 127

    (35) forCont -> DOWNTO expression . DO statement
    (46) expression -> expression . opAdd term
    (48) opAdd -> . +
    (49) opAdd -> . -
    (50) opAdd -> . OR

    DO              shift and go to state 130
    +               shift and go to state 82
    -               shift and go to state 83
    OR              shift and go to state 84

    opAdd                          shift and go to state 75

state 128

    (18) type -> ARRAY [ expression ] OF . type
    (13) type -> . INTEGER
    (14) type -> . REAL
    (15) type -> . STRING
    (16) type -> . CHAR
    (17) type -> . BOOLEAN
    (18) type -> . ARRAY [ expression ] OF type

    INTEGER         shift and go to state 59
    REAL            shift and go to state 60
    STRING          shift and go to state 61
    CHAR            shift and go to state 62
    BOOLEAN         shift and go to state 63
    ARRAY           shift and go to state 64

    type                           shift and go to state 131

state 129

    (34) forCont -> TO expression DO . statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 132
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 130

    (35) forCont -> DOWNTO expression DO . statement
    (21) statement -> . block
    (22) statement -> . assignment
    (23) statement -> . if_statement
    (24) statement -> . while_statement
    (25) statement -> . for_statement
    (26) statement -> . comments
    (27) statement -> . function_call
    (2) block -> . BEGIN statements END terminator
    (28) assignment -> . id ASSIGN expression
    (29) if_statement -> . IF exprBool THEN statement ifCont
    (32) while_statement -> . WHILE expression DO statement
    (33) for_statement -> . FOR id ASSIGN expression forCont
    (75) comments -> . comment
    (69) function_call -> . id ( ) terminator
    (70) function_call -> . id ( arg_list ) terminator

    BEGIN           shift and go to state 9
    id              shift and go to state 25
    IF              shift and go to state 26
    WHILE           shift and go to state 27
    FOR             shift and go to state 28
    comment         shift and go to state 29

    statement                      shift and go to state 133
    block                          shift and go to state 18
    assignment                     shift and go to state 19
    if_statement                   shift and go to state 20
    while_statement                shift and go to state 21
    for_statement                  shift and go to state 22
    comments                       shift and go to state 23
    function_call                  shift and go to state 24

state 131

    (18) type -> ARRAY [ expression ] OF type .

    ;               reduce using rule 18 (type -> ARRAY [ expression ] OF type .)
    CONST           reduce using rule 18 (type -> ARRAY [ expression ] OF type .)
    VAR             reduce using rule 18 (type -> ARRAY [ expression ] OF type .)
    BEGIN           reduce using rule 18 (type -> ARRAY [ expression ] OF type .)


state 132

    (34) forCont -> TO expression DO statement .

    ELSE            reduce using rule 34 (forCont -> TO expression DO statement .)
    END             reduce using rule 34 (forCont -> TO expression DO statement .)
    BEGIN           reduce using rule 34 (forCont -> TO expression DO statement .)
    id              reduce using rule 34 (forCont -> TO expression DO statement .)
    IF              reduce using rule 34 (forCont -> TO expression DO statement .)
    WHILE           reduce using rule 34 (forCont -> TO expression DO statement .)
    FOR             reduce using rule 34 (forCont -> TO expression DO statement .)
    comment         reduce using rule 34 (forCont -> TO expression DO statement .)


state 133

    (35) forCont -> DOWNTO expression DO statement .

    ELSE            reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    END             reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    BEGIN           reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    id              reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    IF              reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    WHILE           reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    FOR             reduce using rule 35 (forCont -> DOWNTO expression DO statement .)
    comment         reduce using rule 35 (forCont -> DOWNTO expression DO statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 105 resolved as shift
